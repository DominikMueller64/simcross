# convert2geno:
#
#' Convert continuous allele information into marker genotypes
#'
#' Convert the continuous crossover location information produced by
#' sim_from_pedigree to marker genotypes
#'
#' @param xodat The sort of detailed genotype/crossover data generated by
#' \code{\link{sim_from_pedigree}}
#' @param map vector of marker locations
#'
#' @return A numeric matrix of genotypes, individuals x markers. If
#' there are just two alleles, the genotypes are coded as 1/2/3. If
#' there are more than two alleles, a binary code is used.
#'
#' @export
#' @keywords utilities
#' @seealso \code{\link{get_geno}}, \code{\link{sim_from_pedigree}}
#'
#' @examples
#' # simulate AIL pedigree
#' tab <- sim_ail_pedigree(12, 30)
#' # simulate data from that pedigree
#' dat <- sim_from_pedigree(tab)
#' # marker map (could also use sim.map in R/qtl)
#' map <- seq(0, 100, by=5)
#' names(map) <- paste0("marker", seq(along=map))
#' # convert data to marker genotypes
#' geno <- convert2geno(dat, map)
convert2geno <-
function(xodat, map)
{
  if(map[1] != 0) map <- map - map[1]
  if(max(map) > max(xodat[[1]]$mat$locations))
    warning("maximum simulated position is less than the length of the map.")

  output <- list(matrix(ncol=length(map), nrow=length(xodat)),
                 matrix(ncol=length(map), nrow=length(xodat)))
  for(i in seq(along=xodat)) {
    for(j in 1:2) {
      dat <- xodat[[i]][[j]]

      toright <- sapply(map, function(marpos, loc) min(which(loc >= marpos)), dat$locations)
      output[[j]][i,] <- dat$alleles[toright]
    }
  }

  if(max(unlist(output)) == 2) { # 2 alleles, so use 1/2/3 codes
    output <- output[[1]] + output[[2]] # becomes 2/3/4
    output[!is.na(output) & output==2] <- 1
    output[!is.na(output) & output==3] <- 2
    output[!is.na(output) & output==4] <- 3
  }
  else # otherwise, use binary codes
    output <- 2^(output[[1]]-1) + 2^(output[[2]]-1)

  # force as integers
  output <- matrix(as.integer(output), ncol=ncol(output))

  dimnames(output) <- list(names(xodat), names(map))

  output
}
